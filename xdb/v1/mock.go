package v1

import (
	"database/sql/driver"
	"fmt"
	"log"
	"reflect"
	"regexp"
	"strings"

	"github.com/DATA-DOG/go-sqlmock"
	"github.com/jinzhu/gorm"
)

const (
	entityFieldName = "Entity"
	columnTag       = "sql-col"
	createdTimeKey  = "created_time"
	graveAccent     = "`"
)

// GormMock defines a Gorm mock
type GormMock struct {
	db   *gorm.DB
	mock sqlmock.Sqlmock
}

// NewGormMock creates a new Gorm DB mock
func NewGormMock() *GormMock {
	gormMock := &GormMock{}
	db, mock, err := sqlmock.New()
	if err != nil {
		log.Fatalf("an error '%s' was not expected when opening a stub database connection", err)
	}

	gormMock.mock = mock
	gormMock.db, err = gorm.Open("mysql", db)
	if err != nil {
		log.Fatalf("an error '%s' was not expected when opening a stub gorm database connection", err)
	}
	gormMock.db.LogMode(true)

	return gormMock
}

func (g *GormMock) ExpectExecWithResult(result driver.Result, query string, args ...driver.Value) {
	g.mock.ExpectBegin()
	g.mock.ExpectExec(formalizeQuery(query)).WithArgs(args...).WillReturnResult(result)
	g.mock.ExpectCommit()
}

func (g *GormMock) ExpectExecWithError(err error, query string, args ...driver.Value) {
	g.mock.ExpectBegin()
	g.mock.ExpectExec(formalizeQuery(query)).WithArgs(args...).WillReturnError(err)
	g.mock.ExpectRollback()
}

func (g *GormMock) ExpectQueryWithResult(rows *sqlmock.Rows, query string, args ...driver.Value) {
	g.mock.ExpectQuery(formalizeQuery(query)).WithArgs(args...).WillReturnRows(rows)
}

func (g *GormMock) ExpectQueryWithError(err error, query string, args ...driver.Value) {
	g.mock.ExpectQuery(formalizeQuery(query)).WithArgs(args...).WillReturnError(err)
}

func (g *GormMock) GormDB() *gorm.DB {
	return g.db
}

func (g *GormMock) Close() error {
	return g.db.Close()
}

// formalizeQuery formalize the sql query
func formalizeQuery(query string) string {
	return "^" + regexp.QuoteMeta(query) + "$"
}

func (g *GormMock) getModelDbColumns(model interface{}) []string {
	fields := g.db.NewScope(model).Fields()

	fieldNames := make([]string, 0, len(fields))
	values := make([]driver.Value, 0, len(fields))

	for _, field := range fields {
		if field.IsIgnored {
			continue
		}
		values = append(values, driver.Value(field.Field.Interface()))
		fieldNames = append(fieldNames, field.DBName)
	}

	return fieldNames
}

func (g *GormMock) getModelValues(model interface{}) []driver.Value {
	fields := g.db.NewScope(model).Fields()
	values := make([]driver.Value, 0, len(fields))

	for _, field := range fields {
		if field.IsIgnored {
			continue
		}
		values = append(values, driver.Value(field.Field.Interface()))
	}

	return values
}

func (g *GormMock) Models2SQLMockRows(models ...interface{}) *sqlmock.Rows {
	if len(models) == 0 {
		log.Fatalf("参数输入异常,至少输入一个model")
	}
	columns := g.getModelDbColumns(models[0])
	sqlMockRows := sqlmock.NewRows(columns)
	for _, expect := range models {
		sqlMockRows.AddRow(g.getModelValues(expect)...)
	}

	return sqlMockRows
}

// GetInsertStmtFromEntity generates insert statement for given Entity by analyzing struct tags
func GetInsertStmtFromEntity(dto interface{}, table string) string {
	dtoType := reflect.TypeOf(dto).Elem()
	numField := dtoType.NumField()
	fieldNames := make([]string, 0, numField)
	valuesPlaceHolder := make([]string, 0, numField)

	for i := 0; i < numField; i++ {
		field := dtoType.Field(i)

		// Skip primary key which can be generated by db itself
		if field.Name == entityFieldName {
			continue
		}
		fieldName := field.Tag.Get(columnTag)
		if fieldName == "" {
			continue
		}
		fieldName = graveAccent + fieldName + graveAccent
		fieldNames = append(fieldNames, fieldName)
		valuesPlaceHolder = append(valuesPlaceHolder, "?")
	}
	columns := strings.Join(fieldNames, ",")
	values := strings.Join(valuesPlaceHolder, ",")

	return fmt.Sprintf("INSERT INTO `%s` (%s) VALUES (%s)", table, columns, values)
}

// GetUpdateStmtFromEntity generates update statement for given Entity by analyzing struct tags
func GetUpdateStmtFromEntity(dto interface{}, table, key string) string {
	dtoType := reflect.TypeOf(dto).Elem()
	numField := dtoType.NumField()
	fieldNames := make([]string, 0, numField)

	for i := 0; i < numField; i++ {
		field := dtoType.Field(i)

		// Skip primary key which can be generated by db itself
		if field.Name == entityFieldName {
			continue
		}
		fieldName := field.Tag.Get(columnTag)
		if fieldName == "" || fieldName == createdTimeKey {
			continue
		}

		fieldName = graveAccent + fieldName + graveAccent
		fieldNames = append(fieldNames, fieldName)
	}
	columns := strings.Join(fieldNames, " = ?, ") + " = ?"
	return fmt.Sprintf("UPDATE `%s` SET %s WHERE `%s`.`%s` = ?", table, columns, table, key)
}
